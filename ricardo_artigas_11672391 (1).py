# -*- coding: utf-8 -*-
"""Ricardo Artigas_11672391.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JLX5IoGnVh4sABpuKddW9rCtKYOTT-eA
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize_scalar
from scipy.stats import dirichlet, chi2
import time


X = [
    [1, 17, 2], [1, 16, 3], [1, 15, 4], [1, 14, 5], [1, 13, 6],
    [1, 12, 7], [1, 11, 8], [1, 10, 9], [1, 9, 10], [1, 8, 11],
    [1, 7, 12], [1, 6, 13], [1, 5, 14], [1, 4, 15], [1, 3, 16],
    [1, 2, 17], [1, 1, 18], [5, 14, 1], [5, 13, 2], [5, 12, 3]
]
priors = {
    "Flat (y=1)": [1, 1, 1],
    "No Prior (y=0)": [0, 0, 0]
}

n = 200000
k = 3000

def densidade_posterior(theta, alpha):
    if np.any(theta <= 0) or np.any(theta >= 1):
        return 0
    return np.prod(theta ** (alpha - 1))

def estatistica_s(theta):
    p_grid = np.linspace(0, 1, 100)
    hw = np.array([[p**2, 2*p*(1-p), (1-p)**2] for p in p_grid])
    dists = np.linalg.norm(hw - theta, axis=1)
    return np.min(dists)


def otimiza_s():
    def neg_s(p):
        theta = np.array([p**2, 2*p*(1-p), (1-p)**2])
        return -estatistica_s(theta)
    res = minimize_scalar(neg_s, bounds=(0, 1), method='bounded')
    p_star = res.x
    theta_star = np.array([p_star**2, 2*p_star*(1 - p_star), (1 - p_star)**2])
    s_star = estatistica_s(theta_star)
    return theta_star, s_star


def std_e(ev):
    t = 2
    df = t
    e_bar = 1 - ev
    q_bar = chi2.cdf(chi2.ppf(e_bar, t), df)
    return 1 - q_bar


def construi_W(potenciais, k):
    pot_ordenado = np.sort(potenciais)
    bin_size = len(potenciais) // k
    v_pontos = [pot_ordenado[i * bin_size - 1] for i in range(1, k + 1)]
    U_vals = [i / k for i in range(1, k + 1)]

    def W(v):
        if v <= v_pontos[0]:
            return 0.0
        if v >= v_pontos[-1]:
            return 1.0
        for i in range(1, len(v_pontos)):
            if v < v_pontos[i]:
                v0, v1 = v_pontos[i - 1], v_pontos[i]
                U0, U1 = U_vals[i - 1], U_vals[i]
                return U0 + (U1 - U0) * (v - v0) / (v1 - v0)
        return 1.0

    return W, v_pontos


start = time.time()
resultados = []

for idx, x in enumerate(X):
    print(f"\nConjunto X[{idx+1}] = {x}")
    for nome_prior, y in priors.items():
        alpha = np.array(x) + np.array(y)
        amostras = dirichlet.rvs(alpha, size=n)
        potencias = np.array([densidade_posterior(t, alpha) for t in amostras])

        W, v_pontos = construi_W(potencias, k)

        theta_star, s_star = otimiza_s()
        v_star = densidade_posterior(theta_star, alpha)
        e_valor = W(v_star)
        sev = std_e(e_valor)

        decisao = "Aceita H" if sev > 0.05 else "Rejeita H"

        print(f"[{nome_prior}] s* = {s_star:.5f}, ev = {e_valor:.5f}, sev = {sev:.5f} => {decisao}")

        resultados.append({
            "X": x, "Prior": nome_prior, "s*": s_star,
            "ev": e_valor, "sev": sev, "decisao": decisao
        })

end = time.time()
print(f"\nTempo total de execução: {end - start:.2f} segundos")